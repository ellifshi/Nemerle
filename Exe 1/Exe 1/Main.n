using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using System.IO.File;
using System;
using System.Collections.Generic;
using System.Console;
using System.Linq;
using System.IO;
using System.Net.Sockets;

class Exe1
{
    public static mutable lableCounter = 0;

    public static add(fs:FileStream) : void
    {
        mutable writer =  StreamWriter(fs);
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("D=M");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("A=M");
        writer.WriteLine("D=D+A"); 
        writer.WriteLine("@SP");
        writer.WriteLine("A=M");
        writer.WriteLine("M=D");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M+1");
        writer.Close();
        fs.Close();
    }
    public static sub(fs:FileStream) : void
    {

        mutable writer =  StreamWriter(fs);
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("D=M");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("A=M");
        writer.WriteLine("D=D-A"); //TODO: not sure if d-a or a-d. should be checked
        writer.WriteLine("@SP");
        writer.WriteLine("A=M");
        writer.WriteLine("M=D");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M+1");
        writer.Close();
        fs.Close();
    }
    public static andd(fs:FileStream) : void
    {
        mutable writer =  StreamWriter(fs);   
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("D=M");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("A=M");
        writer.WriteLine("D=D&A"); 
        writer.WriteLine("@SP");
        writer.WriteLine("A=M");
        writer.WriteLine("M=D");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M+1");
        writer.Close();
        fs.Close();
    }
    public static or(fs:FileStream) : void
    {
        mutable writer =  StreamWriter(fs);
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("D=M");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("A=M");
        writer.WriteLine("D=D|A"); 
        writer.WriteLine("@SP");
        writer.WriteLine("A=M");
        writer.WriteLine("M=D");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M+1");
        writer.Close();
        fs.Close();
    }
    public static eq(fs:FileStream) : void
    {
        mutable fname = fs.Name;

        mutable writer =  StreamWriter(fs);
        
        //pop to D
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("D=M");
        
        //pop to A
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("A=M");
        
        //if a == d jump
        writer.WriteLine("D=D-A");
        def lable1 = "EQ_"+fname+lableCounter;
        lableCounter++;
        writer.WriteLine("@"+lable1);
        writer.WriteLine("D;JEQ");
        
        //else  do d=1 and jump to the end
        writer.WriteLine("D=1");
        def lable2 = "END_"+fname+lableCounter;
        lableCounter++;
        writer.WriteLine("@"+lable2);
        writer.WriteLine("1;JMP");
        
        //if condition
        writer.WriteLine("("+lable1+")");
        writer.WriteLine("D=0");
        
        //end - push d
        writer.WriteLine("("+lable2+")");
        writer.WriteLine("@SP");
        writer.WriteLine("A=M");
        writer.WriteLine("M=D");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M+1");
        
        writer.Close();
        fs.Close();
    }
    public static gt(fs:FileStream) : void
    {
        mutable writer =  StreamWriter(fs);   
        

        writer.Close();
        fs.Close();
    }
    public static lt(fs:FileStream) : void
    {
        mutable writer =  StreamWriter(fs);
        

        writer.Close();
        fs.Close();
    }
    public static neg(fs:FileStream) : void
    {

        mutable writer =  StreamWriter(fs);
        

        writer.Close();
        fs.Close();
    }
    public static not(fs:FileStream) : void
    {
        mutable writer =  StreamWriter(fs);   
        

        writer.Close();
        fs.Close();
    }
    public static push(fs:FileStream, line:String) : void
    {
        mutable words = line.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries);
        
        //assign value to d
        match (words[0]) {
            | "constant" => func2(fs,words[1]);
            | "local" => func1(fs,"LOCAL", words[1]);
            | "argument" => func1(fs,"ARGUMENT",words[1]);
            | "static" => func1(fs,"STATIC",words[1]);
            | "pointer" => ();
            | "this" => ();
            | "that" => ();
            | "temp" => ();
            | _ => ();
        }
        
        mutable writer =  StreamWriter(fs);        
        //push d
        writer.WriteLine("@SP");
        writer.WriteLine("A=M");
        writer.WriteLine("M=D");
        writer.WriteLine("@SP");
        writer.WriteLine("M=M+1");
        writer.Close();
        fs.Close();
    }
    public static func1(fs:FileStream, seg:String, offset:String) : void
    {
        mutable writer =  StreamWriter(fs);   
        writer.WriteLine("@"+seg);
        writer.WriteLine("A=M");
        writer.WriteLine("D=A");
        writer.WriteLine("@"+offset);
        writer.WriteLine("A=D+A");
        writer.WriteLine("D=M");
        writer.Close();
        fs.Close();
    }
    public static func2(fs:FileStream, val:String) : void
    {
        mutable writer =  StreamWriter(fs);
        writer.WriteLine("@"+val);
        writer.WriteLine("D=A");
        writer.Close();
        fs.Close();
    }
    public static pop(fs:FileStream, line:String) : void
    {
        //pop from stack to d
        mutable writer =  StreamWriter(fs);   
        writer.WriteLine("@SP");
        writer.WriteLine("M=M-1");
        writer.WriteLine("A=M");
        writer.WriteLine("D=M");
        writer.Close();
        fs.Close();
        
        mutable words = line.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries);
        match (words[0]) {
            | "local" => ();
            | "argument" => ();
            | "static" => ();
            | "pointer" => ();
            | "this" => ();
            | "that" => ();
            | "temp" => ();
            | _ => ();
        }
    }
    public static func11(fs:FileStream, seg:String, offset:String) : void
    {
        mutable writer =  StreamWriter(fs);   
        writer.WriteLine("@"+seg);
        writer.WriteLine("A=M");
        writer.WriteLine("D=A");
        writer.WriteLine("@"+offset);
        writer.WriteLine("A=D+A");
        writer.WriteLine("");
        writer.Close();
        fs.Close();
    }
    


    //SeesionData hendle all the line, by split the line 
    public static SeesionData(path : string, line : string) : void
    {
        mutable fs : FileStream;
        if (File.Exists(path))
        {
            fs = FileStream(path,FileMode.Append,FileAccess.Write);
        }
        else
        {
            fs =  FileStream(path, FileMode.Create,FileAccess.Write);
        }

        mutable words = line.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries);
    // mutable writer =  StreamWriter(fs);
        for(mutable i = 0; i < words.Length; i++)
        {
            mutable word = words[i];

        // writer.WriteLine(moveTo(fs, word));
            match(word)
            {
                | "add" => add(fs)
                | "sub" => sub(fs)
                | "and" => andd(fs)
                | "or" => or(fs)
                | "eq" => eq(fs)
                | "gt" => gt(fs)
                | "lt" => lt(fs)
                | "neg" => neg(fs)
                | "not" => not(fs)
                | "push" => push(fs, words[i+1]+" "+words[i+2])
                | "pop" => pop(fs, words[i+1]+" "+words[i+2]);
                | _ => ();
            }

        }
        fs.Close();
    }
    public static Main() : void
    {
        mutable contentsOfFile : string = ""; //for the contents of all matching file, (.vm)
        mutable path : string = @"C:\Users\Lenovo\Documents\GitHub\Nemerle\targilim\Exe 1\Exe 1\Folder\";//for the path of all matching file, (.vm)

        foreach (file in Directory.EnumerateFiles(path, "*.vm"))
        {
            contentsOfFile = File.ReadAllText(file); //the contents of file
            path = Path.GetFullPath(file);          //the path of file
            def lines = File.ReadLines(path).Where(line => !line.Contains("//") && !line.Equals("")).ToArray(); // we using in macro NEMERLE that print all line if it NOT commend or empty line

            path = Path.GetFullPath(file).Replace(".vm", ".asm");           //the path of file
            foreach (line in lines)
            {
                // mutable b = line.SplitToList(line.ToArray());
                SeesionData(path, line); // any line that not contain commend, we can sen it to the switch to split the line
            } 
            

        }

       // _ = ReadLine();
    }
}