using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using System.IO.File;
using System;
using System.Collections.Generic;
using System.Console;
using System.Linq;
using System.IO;
using System.Net.Sockets;
using Nemerle.Imperative;
using System.Collections.DictionaryEntry;
using Nemerle.Extensions;
using System.Text.RegularExpressions;
using System.IO.FileAttributes;

namespace Exe_4
{
    class CompilationEngine
    {
        mutable toXMLFile:StreamWriter;
        public mutable token:string;
        public mutable tokesFromTxmlFile:StreamReader;
        
        public this(pathTxmlFile:string ,pathXmlFile:string)             
        {
            tokesFromTxmlFile = fromTxmlToList(pathTxmlFile);
            toXMLFile = StreamWriter(pathXmlFile);
            CompileClass();
            toXMLFile.Close();
        }
        public static fromTxmlToList(pathTXMLFile:string):StreamReader
        {
            mutable allLinesText:StreamReader;
            allLinesText = StreamReader(pathTXMLFile);
            allLinesText;
        }
        public hasMoreTokens():bool
        {
            tokesFromTxmlFile.EndOfStream
        }
        public advance():void
        {
            when(!hasMoreTokens())           
            {
                token = tokesFromTxmlFile.ReadLine();
            }         
        }
        public returnTypeToken():string
        {
            mutable line = token.Split(' ');
            line[0] = line[0].TrimEnd('>');
            line[0] = line[0].TrimStart('<');
            line[0]; //return the token type : keyword/symbol etc
        }   
        public returnKeywordToken():string
        {
            mutable line = token.Split(' ');
            line[1]; //retorn the keyword token : class/function etc
        }
        public returnSymbolToken():string
        {
            mutable line = token.Split(' ');
            line[1]; //return the symbol token : '=', '<' etc.
        }
        public returnIdentifierToken():string
        {
            mutable line = token.Split(' ');
            line[1]; //return the identifier token : main/SquareGame
        }
        public returnIntegerConstantValue():int
        {
            mutable line = token.Split(' ');
            Int32.Parse(line[1]); //return the integer value token : 254, 5 etc.
        }
        public returnStringConstantValue():string
        {
            mutable line = token;
            line = line.Replace("<stringConstant>", "");
            line = line.Replace("</stringConstant>", "");
            line; //return the String Constant Value token : hello world!  
        }
        public isOperandToken():bool
        {
            match(returnSymbolToken())
            {
                | "+"|"-"|"*"|"/"|"&"|"|"|"&lt;"|"&gt;"|"="|"&amp;" =>  true;
                | _=> false;
            }
        }     
        public printXmlPattrenToken(word:string):void
        {
            if(word.Equals("class") || word.Equals("/class")) //we don't neet to space for "class"
            {
                toXMLFile.WriteLine("<" + word + ">");
            }
            else
            {
                countOfIndention ++;
                toXMLFile.WriteLine(Tabs(countOfIndention) + "<" + word + ">");
                countOfIndention --;
            }
        }
        public printXmlPattrenKeyword(word:string):void
        {
            countOfIndention ++;
            toXMLFile.WriteLine(Tabs(countOfIndention) + "<keyword> " + word + " </keyword>"); 
            countOfIndention --;
        }
        public printXmlPattrenIdentifier(word:string):void
        {
            countOfIndention ++;
            toXMLFile.WriteLine(Tabs(countOfIndention) + "<identifier> " + word + " </identifier>"); 
            countOfIndention --;
        }
        public printXmlPattreSymbol(word:string):void
        {
            countOfIndention ++;
            toXMLFile.WriteLine(Tabs(countOfIndention) + "<symbol> " + word + " </symbol>");
            countOfIndention --;
        }
        public printXmlPattrenIntegerConstant(word:int):void
        {
            countOfIndention ++;
            toXMLFile.WriteLine(Tabs(countOfIndention) + "<integerConstant> " + word + " </integerConstant>"); 
            countOfIndention --;
        }
        public printXmlPattreStringConstant(word:string):void
        {
            countOfIndention ++;
            toXMLFile.WriteLine(Tabs(countOfIndention) + "<stringConstant> " + word + " </stringConstant>");
            countOfIndention --;
        }
        public static mutable countOfIndention = 0;
        public static Tabs(countOfIndention:int):string
        {
            mutable tabs :string = string(' ', countOfIndention);
            tabs;
        }
        
        // class:'class' className '{' classVarDec* subroutineDec* '}'
        public CompileClass():void
        {
            printXmlPattrenToken("class");
            advance(); //'tokens'
            advance(); //'class'
            when(returnKeywordToken().Equals("class"))
            {
               printXmlPattrenKeyword(returnKeywordToken());
            }  
            advance(); //className
            when(returnTypeToken().Equals( "identifier"))
            {
                printXmlPattrenIdentifier(returnIdentifierToken());
            } 
            advance();//'{'
            when(returnSymbolToken().Equals("{"))
            {
                printXmlPattreSymbol(returnSymbolToken());
            } 
            advance();//classVarDec*
            while(returnKeywordToken().Equals( "static")  || returnKeywordToken().Equals("field"))
            {
                CompileClassVarDec();
                advance();//next token for classVarDec
            }
            //subroutineDec*
            while(returnKeywordToken().Equals("constructor")  || returnKeywordToken().Equals("function") || returnKeywordToken().Equals( "method"))
            {
                CompileSubroutineDec();
            }

            when(returnSymbolToken().Equals( "}"))//'}'
            {
                printXmlPattreSymbol(returnSymbolToken());
                advance();
            }
            printXmlPattrenToken("/class");
        }
        //'int' | 'char' | 'boolean' | className 
        public CompileType():void
        {
            if(returnTypeToken().Equals("keyword"))
            {
                printXmlPattrenKeyword(returnKeywordToken());
            }
            else
            {
                printXmlPattrenIdentifier(returnIdentifierToken());
            }
            advance();    
        }
        //classVarDec:('static' | 'field' ) type varName (',' varName)* ';' 
        public CompileClassVarDec():void
        {
            countOfIndention ++;
            printXmlPattrenToken("classVarDec");
            printXmlPattrenKeyword(returnKeywordToken());//('static' | 'field' )
            advance();
            CompileType();//type

            when(returnTypeToken().Equals("identifier"))//varName
            {
                printXmlPattrenIdentifier(returnIdentifierToken());
            }    

            advance();//(',' varName)* ';'
            while(returnSymbolToken().Equals(",")) //','
            {
                printXmlPattreSymbol(returnSymbolToken());
                advance();//varName
                when(returnTypeToken().Equals("identifier"))
                {
                    printXmlPattrenIdentifier(returnIdentifierToken());
                }
                advance();
            }
            when(returnSymbolToken().Equals(";")) //';'
            {
                printXmlPattreSymbol(returnSymbolToken());
            }

            printXmlPattrenToken("/classVarDec");
            countOfIndention --;
        }
        //subroutineDec:('constructor' | 'function' | 'method') ('void' | type) subroutineName '(' parameterList ')' subroutineBody
        public CompileSubroutineDec():void
        { 
            countOfIndention ++;
            printXmlPattrenToken("subroutineDec");
            printXmlPattrenKeyword(returnKeywordToken()); //('constructor' | 'function' | 'method')

            advance();        
            CompileType();//('void' | type)

            printXmlPattrenIdentifier(returnIdentifierToken());//subroutineName
            advance();
            printXmlPattreSymbol(returnSymbolToken()); //'('
            advance();
            CompileParameterList();//parameterList
            printXmlPattreSymbol(returnSymbolToken()); //')'
            advance();
            CompileSuroutineBody();//subroutineBody
            printXmlPattrenToken("/subroutineDec");
            countOfIndention --;
        }
        //subroutineBody:'{' varDec* statements '}' 
        public CompileSuroutineBody():void
        {
            countOfIndention ++;
            printXmlPattrenToken("subroutineBody");
            printXmlPattreSymbol(returnSymbolToken());
            advance();
            while(returnKeywordToken().Equals("var")) //varDec
            {
                CompileVarDec();  
            }
            CompileStatements();//statements
            printXmlPattreSymbol(returnSymbolToken());
            advance();
            printXmlPattrenToken("/subroutineBody");
            countOfIndention --;
        }
        //parameterList:( (type varName) (',' type varName)*)? 
        public CompileParameterList():void
        {
            countOfIndention ++;
            printXmlPattrenToken("parameterList");
            when(returnSymbolToken() != ")" )//if its not equal,its mean there are parameters ,ex' where its equal:"function main()"
            {
                CompileType();//type
                printXmlPattrenIdentifier(returnIdentifierToken());
                advance();
                while(returnSymbolToken().Equals(",")) //(',' type varName)*
                {
                    printXmlPattreSymbol(returnSymbolToken());
                    advance();
                    CompileType();
                    printXmlPattrenIdentifier(returnIdentifierToken());//varName
                    advance();
                }
            }
            printXmlPattrenToken("/parameterList");
            countOfIndention --;
        }
        //varDec: 'var' type varName (',' varName)* ';'
        public CompileVarDec():void
        {
            countOfIndention ++;
            printXmlPattrenToken("varDec");
            printXmlPattrenKeyword(returnKeywordToken());//'var'
            advance();
            CompileType();//type
            printXmlPattrenIdentifier(returnIdentifierToken());//varName
            advance();

            while(returnSymbolToken().Equals(",")) //(',' varName)*
            {
                printXmlPattreSymbol(returnSymbolToken());
                advance();
                printXmlPattrenIdentifier(returnIdentifierToken());
                advance();
            }
            printXmlPattreSymbol(returnSymbolToken());//;
            advance();
            printXmlPattrenToken("/varDec");
            countOfIndention --;
        }
        //statements: (letStatement | ifStatement | whileStatement | doStatement | returnStatement)*
        public CompileStatements():void
        {
            countOfIndention ++;
            printXmlPattrenToken("statements");
            while(returnTypeToken().Equals("keyword")) 
            {
                match(returnKeywordToken())
                {
                    |"let" => CompileLet();
                    |"if" => CompileIf();
                    |"while" => CompileWhile();
                    |"do" => CompileDo();
                    |"return" => CompileReturn();
                    |_=>()
                }
            }
            printXmlPattrenToken("/statements");
            countOfIndention --;
        }
        //*doStatement:'do' subroutineCall ';'
        public CompileDo():void
        {
            countOfIndention ++;
            printXmlPattrenToken("doStatement");
            printXmlPattrenKeyword(returnKeywordToken());//'do'
            advance();
            CompileSubroutineCall();//subroutineCall
            printXmlPattreSymbol(returnSymbolToken()); //;
            advance();
            printXmlPattrenToken("/doStatement");
            countOfIndention --;
        }
        //letStatement:'let' varName ('[' expression ']')? '=' expression ';'
        public CompileLet():void
        {
            countOfIndention ++;
            printXmlPattrenToken("letStatement");
            printXmlPattrenKeyword(returnKeywordToken());//let
            advance();
            printXmlPattrenIdentifier(returnIdentifierToken());//varName

            advance();
            when(returnSymbolToken().Equals("[")) //('[' expression ']')?
            {
                printXmlPattreSymbol(returnSymbolToken());//[
                advance();
                CompileExpression();
                printXmlPattreSymbol(returnSymbolToken());//]
                advance();
            }
            printXmlPattreSymbol(returnSymbolToken());//'='
            advance();
            CompileExpression();//expression
            printXmlPattreSymbol(returnSymbolToken());//';'
            advance();
            printXmlPattrenToken("/letStatement");
            countOfIndention --;
        }
        //whileStatement: 'while' '(' expression ')' '{' statements '}'  
        public CompileWhile():void
        {
            countOfIndention ++;
            printXmlPattrenToken("whileStatement");
            printXmlPattrenKeyword(returnKeywordToken()); //'while'
            advance();
            printXmlPattreSymbol(returnSymbolToken()); //'('
            advance();
            CompileExpression();//expression
            printXmlPattreSymbol(returnSymbolToken()); //')'
            advance();
            printXmlPattreSymbol(returnSymbolToken()); //'{'
            advance();
            CompileStatements();//statements
            printXmlPattreSymbol(returnSymbolToken()); //'}'
            advance();
            printXmlPattrenToken("/whileStatement"); 
            countOfIndention --;
        }
        //returnStatement:'return' expression? ';' 
        public CompileReturn():void
        {
            countOfIndention ++;
            printXmlPattrenToken("returnStatement");
            printXmlPattrenKeyword(returnKeywordToken()); //'return'
            advance();
            when(returnSymbolToken() != ";")
            {
                CompileExpression();//expression
            }
            printXmlPattreSymbol(returnSymbolToken()); //';'
            advance();
            printXmlPattrenToken("/returnStatement");  
            countOfIndention --;
        }
        public CompileIf():void
        {
            countOfIndention ++;
            printXmlPattrenToken("ifStatement");
            printXmlPattrenKeyword(returnKeywordToken()); //if
            advance();
            printXmlPattreSymbol(returnSymbolToken()); //'('
            advance();
            CompileExpression();
            printXmlPattreSymbol(returnSymbolToken()); // ')'
            advance();
            printXmlPattreSymbol(returnSymbolToken()); //'{'
            advance();
            CompileStatements();
            printXmlPattreSymbol(returnSymbolToken()); //'}'
            advance();
            when(returnKeywordToken().Equals("else"))
            {
                printXmlPattrenKeyword(returnKeywordToken());
                advance();
                CompileStatements();
                printXmlPattreSymbol(returnSymbolToken());
                advance();
            }
            printXmlPattrenToken("/ifStatement");
            countOfIndention --;
        }
        //expression:term (op term)* 
        public CompileExpression():void
        {
            countOfIndention ++;
            printXmlPattrenToken("expression");
            CompileTerm();//term
            when(isOperandToken())
            {
                printXmlPattreSymbol(returnSymbolToken());
                advance();
            }
            when(!returnSymbolToken().Equals(")") && !returnSymbolToken().Equals(";") && !returnSymbolToken().Equals("]")  && !returnSymbolToken().Equals(","))
            {
                CompileTerm();
            }
            printXmlPattrenToken("/expression");  
            countOfIndention --;
        }
        //term:integerConstant | stringConstant | keywordConstant | varName | varName '[' expression ']' |identifier>subroutineCall | '(' expression ')' | unaryOp term
        public CompileTerm():void
        {
            countOfIndention ++;
            printXmlPattrenToken("term");
            match(returnTypeToken())
            {
                |"integerConstant" =>
                {
                    printXmlPattrenIntegerConstant(returnIntegerConstantValue());
                    advance();
                }
                |"stringConstant"=>
                {
                    printXmlPattreStringConstant(returnStringConstantValue());
                    advance();
                }
                |"keyword" =>
                {
                    printXmlPattrenKeyword(returnKeywordToken());
                    advance();
                }
                |"identifier" =>
                {
                    printXmlPattrenIdentifier(returnIdentifierToken());
                    advance();
                    match(returnSymbolToken())
                    {
                        |"[" =>
                        {
                            printXmlPattreSymbol(returnSymbolToken()); //'['
                            advance();
                            CompileExpression();//
                            printXmlPattreSymbol(returnSymbolToken());
                            advance();
                        }
                        |"("|"." =>
                        {
                            printXmlPattreSymbol(returnSymbolToken()); //'.' OR '('
                            advance();                        
                            CompileSubroutineCall();
                        }
                        |_=>()
                    }
                }
                |"symbol" =>
                {
                    match(returnSymbolToken())
                    {
                        |"(" =>
                        {
                            printXmlPattreSymbol(returnSymbolToken());
                            advance();
                            CompileExpression();//
                            printXmlPattreSymbol(returnSymbolToken());
                            advance();
                        }
                        |"-"|"~" =>
                        {
                            printXmlPattreSymbol(returnSymbolToken());
                            advance();
                            CompileTerm();
                        }
                        |_ =>()
                    }
                }
            } 
            printXmlPattrenToken("/term");
            countOfIndention --;
        } 
        //subroutineCall:subroutineName '(' expressionList ')' | ( className | varName) '.' subroutineName '(' expressionList ')' 
        public CompileSubroutineCall():void
        {
            printXmlPattrenIdentifier(returnIdentifierToken());//subroutineName || ( className | varName)
            advance();
            when(returnSymbolToken().Equals("("))
            {
                printXmlPattreSymbol(returnSymbolToken());//'('
                advance();
                CompileExpressionList();//expressionList
                printXmlPattreSymbol(returnSymbolToken());//')'
                advance();           
            }
            when(returnSymbolToken().Equals("."))
            {
                printXmlPattreSymbol(returnSymbolToken());//'.'
                advance();
                printXmlPattrenIdentifier(returnIdentifierToken());//subroutineName
                advance();
                printXmlPattreSymbol(returnSymbolToken());//'('
                advance();
                CompileExpressionList();//expressionList
                printXmlPattreSymbol(returnSymbolToken());//')'
                advance();       
            }
        }
        //expressionList:(expression (',' expression)* )? 
        public CompileExpressionList():void
        {
            countOfIndention ++;
            printXmlPattrenToken("expressionList");
            when(returnSymbolToken() != ")")
            {
                CompileExpression();//expression

                while(returnSymbolToken().Equals(","))
                {
                    printXmlPattreSymbol(returnSymbolToken());//','
                    advance();
                    CompileExpression();//expression
                }
            }
            printXmlPattrenToken("/expressionList");     
            countOfIndention --;
        }
    }
}