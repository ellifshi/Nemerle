using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using System.IO.File;
using System;
using System.Collections.Generic;
using System.Console;
using System.Linq;
using System.IO;
using System.Net.Sockets;
using Nemerle.Imperative;
using System.Collections.DictionaryEntry;
using Nemerle.Extensions;

namespace Exe_4
{
    class CompilationEngine
    {
        public static returnIfKeyWord(word:string): bool
        {
            JackTokenizer.KeyWords.Contains(word); //bool      
        }
        public static returnIfOpKeword(word:string):bool
        {
            JackTokenizer.opKeyWord.Contains(word); 
        }
        
        public static printTokens(word:string, fs:FileStream):void
        {
            mutable writer =  StreamWriter(fs);  

            writer.WriteLine(word);

        }
        public static sessionData(lines:array[string], pathXMLFile:string):void
        {
            mutable fs : FileStream;
            
            
            mutable theFullLIst = List();
            if (File.Exists(pathXMLFile))
            {
                fs = FileStream(pathXMLFile,FileMode.Append,FileAccess.Write);
            }
            else
            {
                fs =  FileStream(pathXMLFile, FileMode.Create,FileAccess.Write);
            }
            mutable writer = StreamWriter(fs);  
            CompileClass(lines, theFullLIst);
            foreach(line in theFullLIst)
            {
                writer.WriteLine(line);
            }
            
            writer.Close();
            fs.Close();
  
        }
        
        // 'class' className '{' classVarDec* subroutineDec* '}' 
        public static CompileClass(lines:array[string], theFullLIst:List[String]):void
        {
            mutable newLines = List();
            foreach(line in lines)
            {
                newLines.Add(line);
            }  

            foreach(line in newLines)
            {
                if(line.StartsWith("class"))
                {
                    theFullLIst.Add("<class>");
                    mutable words = line.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries);  
                    theFullLIst.Add("<keyword> " + words[0] + " </keyword>");
                    theFullLIst.Add("<identifier> " + words[1] + " </identifier>");
                    theFullLIst.Add("<symbol> " + words[2] + " </symbol>");
                    //newLines.RemoveAt(line.IndexOf(line));          
                }
                else if(line.StartsWith("static") || line.StartsWith("field"))
                {     
                    CompileClassVarDec(newLines, theFullLIst);
                }
                else if(line.StartsWith("constructor") || line.StartsWith("function") || line.StartsWith("method"))
                {
                    CompileSubroutineDec(line, theFullLIst);

                    //newLines.RemoveAt(line.IndexOf(line));
                }
                else if(line.StartsWith("var"))
                { 
                    compileVarDec(line, theFullLIst);
                    //newLines.RemoveAt(line.IndexOf(line));
                }
                else if(line.StartsWith("let") || line.StartsWith("while") ||line.StartsWith("do") ||line.StartsWith("return") ||line.StartsWith("if"))
                {
                    compileStatements(line, theFullLIst);
                } 
                else if(line.StartsWith("}"))
                {
                   theFullLIst.Add("<symbol> " + line + " </symbol>");
                }
                else
                {}         
            }       
            theFullLIst.Add("</class>");   
        }
        
        
        // ('static' | 'field' ) type varName (',' varName)* ';'
        public static CompileClassVarDec(newlines:List[string], theFullLIst:List[String]):void
        {
            theFullLIst.Add("<classVarDec>");
            mutable words = newlines[0].Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries);  
            theFullLIst.Add("<keyword> " + words[0] + " </keyword>");
            foreach(word in words)
            {
                if(returnIfKeyWord(word))//for type
                {
                    CompileType(word, theFullLIst);
                }
                else if(word.Equals(","))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else if(!returnIfKeyWord(word))//varName
                {
                    theFullLIst.Add("<identifier> " + word + " </identifier>");
                }
                else if(word.Equals(")"))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else if(!word.Equals("("))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else if(word.Equals(";"))
                {
                    theFullLIst.Add("  <symbol> " + word + " </symbol>");
                }
                else
                {
                }                 
            }
            theFullLIst.Add("</classVarDec>");
        }
        
        // 'int' | 'char' | 'boolean' | className 
        public static CompileType(word:string, theFullLIst:List[String]):void
        {
            if(returnIfKeyWord(word))         
            {
                theFullLIst.Add("<keyword> " + word + " </keyword>");
            }
            else
            {
                theFullLIst.Add("<identifier> " + word + " </identifier>");
            }
        }
        
        
        //TODO subRoutinsBody   
        // ('constructor' | 'function' | 'method') ('void' | type) subroutineName '(' parameterList ')' subroutineBody
        public static CompileSubroutineDec(line:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<subroutineDec>");
            mutable start = line.IndexOf("(");
            mutable end = line.IndexOf(")");
            mutable parameterList = line.Substring(start + 1, end - start - 1);
            
            mutable words = line.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries);  
            foreach(word in words)
            {
                if(word.Equals("constructor") || word.Equals("function") || word.Equals("method"))
                {
                    theFullLIst.Add("<keyword> " + word + " </keyword>");
                }
                else if (word.Equals("void") || word.Equals("type"))
                {
                    theFullLIst.Add("<keyword> " + word + " </keyword>");
                }
                else if(word.Equals("("))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");                    
                }
                 else if(word.Equals(")"))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");                   
                }
                else if(!parameterList.Equals(" "))
                {
                    compileParameterList(parameterList, theFullLIst);               
                }
                else if(!returnIfKeyWord(word))
                {
                    compileSubroutineName(word, theFullLIst);               
                }
                else
                {}
            }
            compileSubroutineBody("", theFullLIst:List[string]);
            theFullLIst.Add("</subroutineDec>");
            
        }
        
        // ((type varName) (',' type varName)*)?
        public static compileParameterList(word:string, theFullLIst:List[String]):void
        {
            mutable words = word.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries); 
            theFullLIst.Add("<parameterList>");
            foreach(word in words)
            {
                if(word.Equals("int") || word.Equals("char") || word.Equals("boolean"))
                {
                    CompileType(word, theFullLIst);
                    
                }
                else if(word.Equals(","))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else
                {
                    compileVarName(word, theFullLIst);
                }
            }
                
            theFullLIst.Add("</parameterList>");
            
        }
        
        // '{' varDec* statements '}' 
        public static compileSubroutineBody(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<subroutineBody>");
            theFullLIst.Add("<symbol> { </symbol>");
            while(word.Equals("var"))
            {
                compileVarDec(word, theFullLIst);
            }
            compileStatements(word:string, theFullLIst:List[String]);
            theFullLIst.Add("<symbol> } </symbol>");
            theFullLIst.Add("</subroutineBody>");
        }
        
        // 'var' type varName (',' varName)* ';'
        public static compileVarDec(line:string, theFullLIst:List[String]):void
        {

            mutable words = line.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries); 
            theFullLIst.Add("<varDec> ");
            theFullLIst.Add("<keyword> " + "var" + " </keyword>");
            
            foreach(word in words)
            {
                if(returnIfKeyWord(word))
                {
                    CompileType(word, theFullLIst);//type
                }
                else if(!returnIfKeyWord(word))
                {
                    compileVarName(word, theFullLIst);
                }
                else if(word.Equals("("))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else if(word.Equals(","))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else if(word.Equals(")"))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else if(word.Equals(";"))
                {
                    theFullLIst.Add("<symbol> " + word + " </symbol>");
                }
                else
                {
                }
            }       
            theFullLIst.Add("</varDec> ");     
        }
        
        // identifier
        public static compileClassName(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<identifier> " + word + " </identifier>");
        }
        
        // identifier
        public static compileSubroutineName(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<identifier> " + word + " </identifier>");       
        }
        
        // identifier
        public static compileVarName(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<identifier> " + word + " </identifier>");
        }
        
        // statement* 
        public static compileStatements(line:string,theFullLIst:List[String]):void
        {
            theFullLIst.Add("<statements>");
            
            compileStatement(line, theFullLIst);
            
            theFullLIst.Add("</statements>");    
        }
        
         // letStatement | ifStatement | whileStatement | doStatement | returnStatement 
        public static compileStatement(line:string, theFullLIst:List[String]):void
        {
            if(line.StartsWith("let"))
            {
                compileLetStatement(line, theFullLIst);
            }
            else if(line.StartsWith("if"))
            {
                compileIfStatement(line, theFullLIst);
            }
            else if(line.StartsWith("while"))
            {
                compileWhileStatement(line, theFullLIst);
            }
            else if(line.StartsWith("do"))
            {
                compileDoStatement(line, theFullLIst);
            }
            else
            {
                compileReturnStatement(line, theFullLIst);
            }
        }
        
        // 'let' varName ('[' expression ']')? '=' expression ';'
        public static compileLetStatement(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<letStatement>");
            theFullLIst.Add("<keyword> let </keyword>");

            mutable words = word.Split(" ".ToArray(), StringSplitOptions.RemoveEmptyEntries); 

            foreach(word in words)
            {
                if(word.Equals("[") || word.Equals("]") || word.Equals("=") ||word.Equals(";"))
                {
                    theFullLIst.Add("<symbol>" + word +  " </symbol>");           
                }
                else if(!returnIfKeyWord(word))
                {
                    theFullLIst.Add("<identifier> " + word + " </identifier>");
                }
                else
                {
                    compileVarName(word, theFullLIst);
                }
            }
            //TODO  expression 
            theFullLIst.Add("</letStatement>");
            
        }
        
        // 'if' '(' expression ')' '{' statements '}' ( 'else' '{' statements '}' )?
        public static compileIfStatement(word:string, theFullLIst:List[String]):void
        {
        }
        
        // 'while' '(' expression ')' '{' statements '}' 
        public static compileWhileStatement(word:string, theFullLIst:List[String]):void
        {
        }
        
        // 'do' subroutineCall ';'
        public static compileDoStatement(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<doStatement>");
            theFullLIst.Add("<keyword> do </keyword>");
            CompileSubroutineCall(word, theFullLIst);
            theFullLIst.Add("<symbol> ; </symbol>");
            theFullLIst.Add("</doStatement>");   
        }
        
        // 'return' expression? ';' 
        public static compileReturnStatement(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<returnStatement>");
            theFullLIst.Add("<keyword>" + word + "</keyword>");
            theFullLIst.Add("<symbol>" ";" "</symbol>");
            theFullLIst.Add("</returnStatement>");
        }
        
        // term (op term)* 
        public static CompileExpression(word:string, theFullLIst:List[String]):void
        {
        }
        
        // integerConstant | stringConstant | keywordConstant | varName | varName '[' expression ']' | subroutineCall | '(' expression ')' | unaryOp term
        public static CompileTerm(word:string, theFullLIst:List[String]):void
        {
        }
        
        // subroutineName '(' expressionList ')' | ( className | varName) '.' subroutineName '(' expressionList ')' 
        public static CompileSubroutineCall(word:string, theFullLIst:List[String]):void
        {
        }
        
        // (expression (',' expression)* )?
        public static CompileExpressionList(word:string, theFullLIst:List[String]):void
        {
        }
        
        // '+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '=' 
        public static CompileOp(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<symbol> " + word + " </symbol>");
        }
         // '-' | '~' 
        public static CompileUnaryOp(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<expression>");
            theFullLIst.Add("<term>");
            theFullLIst.Add("<symbol> " + word + " </symbol>");
            theFullLIst.Add("</term>");
            theFullLIst.Add("</expression>");
        }
         // 'true' | 'false' | 'null' | 'this' 
        public static CompileKeywordConstant(word:string, theFullLIst:List[String]):void
        {
            theFullLIst.Add("<expression>");
            theFullLIst.Add("<term>");
            theFullLIst.Add("<keyword> " + word + " </keyword>");
            theFullLIst.Add("</term>");
            theFullLIst.Add("</expression>");
        }
    }
}